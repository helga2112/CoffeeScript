// Generated by CoffeeScript 2.3.2
(function() {

  /*
      Move the shape
  */
  /*
     - create grid
     - add shape motion
  */
  var Figure, a, addItem, checkMoves, figures, gridStep, interval, maxCells, onKeyup, ready, removeLines, removeRow, shapes, takenCells;

  maxCells = 100;

  gridStep = 10;

  interval = -1;

  figures = ['square', 'shifted', 'corner', 'letterT', 'tower'];

  shapes = {
    square: [0, 1, 10, 11],
    shifted: [0, 1, 11, 12],
    corner: [0, 10, 20, 21],
    letterT: [0, 1, 2, 11],
    tower: [0, 10, 20, 30]
  };

  takenCells = [];

  ready = function() {
    var a, i, j, newElement, parent, ref;
    parent = document.body.appendChild(document.createElement('div'));
    parent.className = 'grid-container';
    for (i = j = 0, ref = maxCells; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
      newElement = parent.appendChild(document.createElement('div'));
      newElement.innerHTML = '<p>' + i + '</p>';
      newElement.className = 'grid-item' + i;
    }
    return a = 0;
  };

  interval = setInterval((function() {
    return addItem();
  }), 1000);

  onKeyup = function(e) {
    if (e.keyCode === 37) {
      if (a.isMoving) {
        return a.shift(-1);
      }
    } else if (e.keyCode === 39) {
      if (a.isMoving) {
        return a.shift(1);
      }
    }
  };

  document.addEventListener("DOMContentLoaded", ready);

  document.addEventListener('keyup', onKeyup);

  Figure = (function() {
    var canContinue, canShift, colorPrev, colorSelected, colors, setColor;

    class Figure {
      
      // move the figure to the right or to the left (on user key up)
      shift(num) {
        var i, results, temp;
        if (canShift(this.shape, num)) {
          for (i in this.shape) {
            temp = document.getElementsByClassName('grid-item' + this.shape[i]);
            temp[0].style.backgroundColor = colorPrev;
          }
          results = [];
          for (i in this.shape) {
            this.shape[i] += num;
            temp = document.getElementsByClassName('grid-item' + this.shape[i]);
            results.push(temp[0].style.backgroundColor = 'green');
          }
          return results;
        }
      }

      // move the figure down each second
      move(newPos) {
        var clean, i, results, temp;
        if (newPos) {
          results = [];
          for (i in this.shape) {
            this.shape[i] += newPos;
            temp = document.getElementsByClassName('grid-item' + this.shape[i]);
            results.push(temp[0].style.backgroundColor = colorSelected);
          }
          return results;
        } else {
          //clean prev cells
          clean = document.getElementsByTagName('div');
          [].forEach.call(clean, function(item) {
            var num;
            if (item.className !== 'grid-container') {
              num = item.className.slice('grid-item'.length, item.className.length);
              if (!takenCells.includes(+num)) {
                return item.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
              }
            }
          });
          // check if can continue moving
          if (canContinue(this.shape, takenCells, gridStep)) {
            return setColor(this.shape, gridStep);
          } else {
            setColor(this.shape);
            this.isMoving = false;
            takenCells = [...takenCells, ...this.shape];
          }
        }
      }

    };

    colors = ['green', 'yellow', 'blue', 'aqua', 'pink'];

    colorSelected = 'green';

    colorPrev = 'rgba(255, 255, 255, 0.8)';

    Figure.prototype.shape = [];

    Figure.prototype.isMoving = false;

    // check if the figure can be shifted
    canShift = function(arr, num) {
      var t;
      if (num < 0) {
        for (t in arr) {
          if ((+arr[t] + num) % gridStep < 0) {
            return false;
          }
        }
      }
      if (num > 0) {
        for (t in arr) {
          if ((+arr[t] % gridStep + num) >= gridStep) {
            return false;
          }
        }
      }
      return true;
    };

    setColor = function(array, delta = 0) {
      var i, results, temp;
      results = [];
      for (i in array) {
        array[i] = array[i] + delta;
        temp = document.getElementsByClassName('grid-item' + array[i]);
        results.push(temp[0].style.backgroundColor = colorSelected);
      }
      return results;
    };

    //check if the shape can move on
    canContinue = function(array, takenCells, gridStep) {
      var a, i;
      a = array.slice();
// a.forEach((element)-> element + gridStep)
      for (i in a) {
        a[i] += gridStep;
        if (takenCells.includes(a[i])) {
          return false;
        } else if (a[i] > maxCells) {
          return false;
        }
      }
      return true;
    };

    return Figure;

  }).call(this);

  removeLines = function() {
    var a, controll, currentRow, d, end, i, j, r, ref, results, rowSum, rowToRemove, start;
    controll = 0;
    for (a = j = 0, ref = gridStep; (0 <= ref ? j < ref : j > ref); a = 0 <= ref ? ++j : --j) {
      controll += a;
    }
    r = [];
    takenCells = takenCells.sort();
    currentRow = -1;
    rowSum = 0;
    rowToRemove = [];
    if (takenCells.length > 0) {
      results = [];
      for (i in takenCells) {
        d = Math.floor(takenCells[i] / gridStep);
        if (d !== currentRow) {
          if (rowSum === controll) {
            removeRow(rowToRemove);
            start = takenCells.indexOf(rowToRemove[0]);
            end = takenCells.indexOf(rowToRemove[rowToRemove.length]);
            takenCells = takenCells.slice(start, end);
          }
          rowSum = 0;
          currentRow = d;
          rowToRemove = [];
        }
        rowSum += takenCells[i] % gridStep;
        results.push(rowToRemove.concat(takenCells[i]));
      }
      return results;
    }
  };

  removeRow = function(array) {
    var i, results, temp;
    results = [];
    for (i in array) {
      temp = document.getElementsByClassName('grid-item' + array[i]);
      results.push(temp[0].style.backgroundColor = 'rgba(255, 255, 255, 0.8)');
    }
    return results;
  };

  checkMoves = function() {
    var a, j, results;
    results = [];
    for (a = j = 0; j < 9; a = ++j) {
      if (takenCells.indexOf(a) > -1) {
        console.log('STOP');
        results.push(clearInterval(interval));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  a = new Figure();

  addItem = function() {
    var ind, ramdonFigure;
    if (!a.isMoving) {
      removeLines();
      checkMoves();
      a.isMoving = true;
      
      // define random figure
      ind = 0; //Math.floor(Math.random() * 5)
      ramdonFigure = figures[ind];
      a.shape = shapes[ramdonFigure].slice();
      // make it move
      return a.move(Math.round(Math.random() * 10));
    } else {
      return a.move();
    }
  };

}).call(this);
